---
title: '位运算题目的技巧'
date: 2022-05-19
permalink: /posts/2022/05/bit-op
tags: 
    - Leetcode
---

今天在刷leetcode的时候, 看到了很多有趣的思路, 明明也很简单, 就是没想到的一些算法, 在这里记录分享一下.

## 231. Power of Two

这是一道easy题目, 但题目进阶要求是, 不许使用循环或递归.

当时就想着用位运算, 但没想出办法.看题解有两个推论可以理解记忆一下:

> 1. 对于2的幂次, n & (n-1) = 0. 因为n-1正好将最低位的1设为0, 后续设为1, 只有只存在这一个1时, 结果才为0, 否则结果不为0
> 2. 对于2的幂次, n & (~n+1) == n. 因为(~n+1)正好将低位全为0, i到最高位为1, 此时相&结果和n相等, 其他数字并没有这个效果.

## 191. Number of 1 Bits & 190. Reverse Bits

统计一个二进制bit串中1的个数, 使用简单的遍历肯定可以, 看题解的时候看到了一个有趣的算法: 平行算法. 该算法在大型数据或者分布式场景下效果应该更好.

```cpp
    int hammingWeight(uint32_t n) {
        n = (n&0x55555555) + (n >> 1 & 0x55555555);
        n = (n&0x33333333) + (n >> 2 & 0x33333333);
        n = (n&0x0f0f0f0f) + (n >> 4 & 0x0f0f0f0f);
        n = (n&0x00ff00ff) + (n >> 8 & 0x00ff00ff);
        n = (n&0x0000ffff) + (n >> 16& 0x0000ffff);
        return n;
    }
```
算法的思路是, 先2个2个统计1的个数; 再4个4个统计1的个数; ...; 直到16个16个统计完后, 得到对32bit数据的1的个数统计值.

很有趣的一个思路.

190 题目是颠倒bit串, 使用遍历算法也可以很简单地解出来, 但这里也可以使用上面类似的算法:

```cpp
    uint32_t reverseBits(uint32_t n) {
        n = ((n>>1)&0x55555555) | (n&0x55555555)<<1;
        n = ((n>>2)&0x33333333) | (n&0x33333333)<<2;
        n = ((n>>4)&0x0f0f0f0f) | (n&0x0f0f0f0f)<<4;
        n = ((n>>8)&0x00ff00ff) | (n&0x00ff00ff)<<8;
        n = n>>16 | n << 16;
        return n;
    }
```

即bit串的颠倒 == 长度为2的子串的颠倒, 4, 8, 16,32...

看着代码理解应该不难.

## 136. Single Number

哇, 这道题也很有趣, vector的数字只有一个出现了一次, 其他都出现2次.

这道题我想使用排序, 遍历的通用思路解答, 发现效果并不好, 太费时和内存. 且没有利用题目给出的信息.

看了题解发现, 可以使用异或运算的, 因为出现两次异或一定为0, 0异或一个数字为其本身:

```cpp
    int singleNumber(vector<int>& nums) {
        int len = nums.size(); 
        int ans = 0;
        for(int i=0; i<len; ++i){
            ans = ans^nums[i];
        }
        return ans;
    }
```

bit运算这些题目让我又想起了CSAPP刚开始学的那段时间, 很怀念, 也很好玩呀!

